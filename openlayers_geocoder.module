<?php
// $Id$

/**
 * @file
 * Add geocoding capabilities to OpenLayer CCK widget.
 *
 * @ingroup openlayers
 */

define('GOOGLE_GEOCODER_URL', 'http://maps.google.com/maps/api/geocode/json?');
define('GOOGLE_GEOCODER_STATUS_OK', 'OK');


/**
 * Implementation of hook_init()
 */
function openlayers_geocoder_init() {
  module_load_include('inc', 'openlayers_geocoder', 'includes/openlayers_geocoder.theme');
  module_load_include('inc', 'openlayers_geocoder', 'includes/openlayers_geocoder.token');
}

/**
 * Implementation of hook_menu().
 */
function openlayers_geocoder_menu() {
  $items = array();
  $items['openlayers/geocoder'] = array(
    'page callback' => 'openlayers_geocoder_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['openlayers/geocoder/coordinates'] = array(
    'page callback' => 'openlayers_geocoder_coordinates',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implementation of hook_widget_info().
 */
function openlayers_geocoder_widget_info() {
  return array(
    'openlayers_geocoder_widget' => array(
      'label' => t('OpenLayers Geocoder'),
      'field types' => array('openlayers_wkt', 'geo'),
      'multiple values' => CONTENT_HANDLE_MODULE,
      'callbacks' => array(
        'default value' => CONTENT_CALLBACK_DEFAULT,
      ),
    ),
  );
}

/**
 * Implementation of hook_widget_settings().
 */
function openlayers_geocoder_widget_settings($op, $widget) {
  switch ($op) {
    case 'form':
      $form = module_invoke('openlayers_cck', 'widget_settings', 'form', $widget);

      if (module_exists('token')) {

        $form['autocompletion'] = array(
          '#type' => 'fieldset',
          '#title' => t('Autocompletion'),
          '#collapsible' => TRUE,
          '#collapsed' => FALSE,
          '#description' => t('Autocomplete CCK text fields with geocoding response values. Check <em>"Enable"</em> to activate autocompletion of a specified field. Check <em>"Override"</em> to let users override field values after autocompletion took place. Fill <em>"Content"</em> using the replacement patterns listed below.'),
          '#theme' => 'openlayers_geocoder_widget_autocompletion_settings',
        );

        foreach (content_fields() as $name => $field) {
          if ($field['type_name'] == arg(3) && $field['widget']['type'] == 'text_textfield') {
            $row = array();
            $row['autocompletion_'. $name .'_enable'] = array('#type' => 'checkbox', '#default_value' => $widget['autocompletion_'. $name .'_enable']);
            $row['autocompletion_'. $name .'_override'] = array('#type' => 'checkbox', '#default_value' => $widget['autocompletion_'. $name .'_override']);
            $row['autocompletion_'. $name .'_field'] = array('#value' => $field['widget']['label']);
            $row['autocompletion_'. $name .'_content'] = array('#type' => 'textfield', '#default_value' => $widget['autocompletion_'. $name .'_content']);
            $form['autocompletion'][] = $row;
          }
        }

        $form['autocompletion']['token_help'] = array(
          '#title' => t('Replacement patterns'),
          '#type' => 'fieldset',
          '#collapsible' => TRUE,
          '#collapsed' => TRUE,
        );

        $form['autocompletion']['token_help']['help']['#value'] = theme('token_help', 'geocoder');

      }
      return $form;

    case 'save':
      $elements = module_invoke('openlayers_cck', 'widget_settings', 'save', $widget);
      foreach (content_fields() as $name => $field) {
        if ($field['type_name'] == arg(3) && $field['type'] == 'text') {
          $elements[] = 'autocompletion_'. $name .'_enable';
          $elements[] = 'autocompletion_'. $name .'_override';
          $elements[] = 'autocompletion_'. $name .'_content';
        }
      }
      return $elements;
  }
}

/**
 * Implementation of hook_widget().
 */
function openlayers_geocoder_widget(&$form, &$form_state, $field, $items, $delta = 0) {

  drupal_add_css(drupal_get_path('module', 'openlayers_geocoder') .'/openlayers_geocoder.css');
  drupal_add_js(drupal_get_path('module', 'openlayers_geocoder') .'/js/openlayers_geocoder.js');

  $element = array();
  $element = module_invoke('openlayers_cck', 'widget', $form, $form_state, $field, $items, $delta);

  $element['openlayers_geocoder_query'] = array(
    '#title' => t('Search address'),
    '#type' => 'textfield',
    '#autocomplete_path' => 'openlayers/geocoder',
    '#weight' => 1,
    '#attributes' => array(
      'geoautocomplete' => TRUE,
      'fieldname' => $field['field_name'],
      'dashed' => str_replace('_', '-', $field['field_name']),
    ),
  );

  $element['#type'] = 'openlayers_wkt_widget';
  $element['#default_value'] = $items;

  return $element;
}

/**
 * Implementation of hook_theme().
 */
function openlayers_geocoder_theme($existing, $type, $theme, $path) {
  return array(
    'openlayers_geocoder_result' => array(
      'arguments' => array('result' => NULL),
      'template' => 'openlayers-geocoder-result',
      'path' => drupal_get_path('module', 'openlayers_geocoder') .'/theme',
    ),
    'openlayers_geocoder_widget_autocompletion_settings' => array(
      'arguments' => array('form' => NULL),
    ),
  );
}

/**
 * Location list from Google geocoding web service
 *
 * @param $query
 *    Address or location name
 * @return
 *    List of locations
 */
function openlayers_geocoder_autocomplete($query = '') {

  $locations = array();
  if ($response = openlayers_geocoder_response($query)) {
    foreach ($response as $location) {
      $locations[$location['address']] = theme('openlayers_geocoder_result', $location['components']);
    }
  }
  drupal_json($locations);
}

/**
 * Return coordinates of a location.
 *
 * @return
 *    Lat/Lan coordinates
 */
function openlayers_geocoder_coordinates() {

  $location['latitude'] = 0;
  $location['longitude'] = 0;
  $location['box'] = array();
  $location['fields'] = array();

  $query = $_POST['query'];
  $fieldname = $_POST['fieldname'];

  if ($response = openlayers_geocoder_response($query)) {

    $result = array_shift($response);
    $location['latitude'] = $result['location']['lat'];
    $location['longitude'] = $result['location']['lng'];
    $location['box']['north'] = $result['bounds']['northeast']->lat;
    $location['box']['east'] = $result['bounds']['northeast']->lng;
    $location['box']['south'] = $result['bounds']['southwest']->lat;
    $location['box']['west'] = $result['bounds']['southwest']->lng;

    $field = content_fields($fieldname);
    if (module_exists('token') && $field && $field['widget']['type'] == 'openlayers_geocoder_widget') {
      $fields = openlayers_geocoder_widget_parse_settings($field['widget']);
      foreach ($fields as $name => $settings) {
        if ($settings['enable']) {
          $location['fields'][$name]['value'] = token_replace($settings['content'], 'geocoder', $result);
          $location['fields'][$name]['name'] = $name;
          $location['fields'][$name]['override'] = $settings['override'];
        }
      }
    }
  }
  drupal_json($location);
}

/**
 * Query Google geocoding web service
 * @param $address
 *    Address or location name
 * @return
 *    Array of placemarks
 */
function openlayers_geocoder_response($address) {

  $locations = $args = array();

  // The address that you want to geocode.
  $args['address'] = str_replace(' ', '+', $address);

  // The language in which to return results. If "language" is not supplied,
  // the geocoder will attempt to use the native language of the domain
  // from which the request is sent wherever possible.
  $language = language_default();
  $args['language'] = $language->language;

  // Response encoding.
  $args['oe'] = 'utf-8';

  //  Indicates whether or not the geocoding request comes from a device with a location sensor. This value must be either true or false.
  $args['sensor'] = 'false';

  //The textual latitude/longitude value for which you wish to obtain the closest, human-readable address.
  // $args['latlng'] = '40.714224,-73.961452';

  // The bounding box of the viewport within which to bias geocode results more prominently.
  // $args['bounds'] = '';

  // The region code, specified as a ccTLD ("top-level domain") two-character value.
  // $args['region'] = '';

  $query = http_build_query($args, '', '&');
  $response = json_decode(file_get_contents(GOOGLE_GEOCODER_URL . $query));

  if ($response->status == GOOGLE_GEOCODER_STATUS_OK) {
    foreach ($response->results as $result) {
      $location = $components = array();
      foreach ($result->address_components as $component) {
        $key = $component->types[0];
        $components[$key] = $component->long_name;
        if ($key == 'country') {
          $components['country_code'] = $component->short_name;
        }
      }
      $components['street_address'] = $location['address'] = $result->formatted_address;
      $location['components'] = $components;
      $location['location'] = (array) $result->geometry->location;
      $location['bounds'] = (array) $result->geometry->bounds;
      $locations[] = $location;
    }
  }
  return $locations;
}

/**
 * Helper function: parse widget settings to retreive
 * CCK field mapping information
 *
 * @param $widget
 *    Field widget.
 */
function openlayers_geocoder_widget_parse_settings(&$widget) {
  $settings = array();
  foreach ($widget as $key => $value) {
    if (preg_match_all('/autocompletion_(.*)_(enable|override|content)/', $key, $matches)) {
      $settings[$matches[1][0]][$matches[2][0]] = $value;
    }
  }
  return $settings;
}
